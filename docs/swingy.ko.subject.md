# Swingy
- GUI programming in Java
- 요약
  - 이것은 42에서 Java world으로부터의 두 번째 프로젝트입니다.  
    당신은 SWING framework와 함께 GUI application을 만드는 법을 배울 것입니다.

## 서문
서기 932년 영국, King Arthur는 후작 Patsy와 함께 원탁의 기사단을 모집합니다.  
현명한 Bedevere 경, 용맹한 Lancelot 경, 순수한 Galahad 경, 그리고
Lancelot 경만큼 용감하지 않은 Robin 경, 그리고 이 영화에 등장하지 않는 경이라는 적절한 이름을 가진 경까지요.   
도중에 Arthur는 Black Knight와 전투를 벌이는데, 팔과 다리가 잘려나갔음에도 불구하고 계속 싸웁니다.
(King Arthur는 전투가 끝날 무렵 이렇게 선언합니다. "좋아, 무승부라고 부르자.")  
기사들은 Camelot에 도착하지만, 노래와 춤이 어우러진 컷어웨이를 본 King Arthur는 "어리석은 곳"이라며 들어가지 않기로 결심합니다.  
그룹은 곧 성배를 찾으라는 지시를 내린 신을 만나게 됩니다(영국 크리켓 선수 W.G. Grace의 컷아웃 애니메이션으로 보여짐).

## 소개
이 프로젝트는 Academy+Plus에서 제작한 4개의 Java 프로젝트 시리즈 중 두 번째 프로젝트입니다.  
이번에는 GUI와 관련 소프트웨어 디자인 패턴에 초점을 맞출 것입니다.  
컴퓨터 소프트웨어와 인간의 상호 작용은 많은 문제를 야기하며 특정 솔루션이 필요합니다.  
Object Oriented Programming은 이러한 종류의 문제에 잘 맞는 패러다임이지만, event-driven programming 같은 새로운 아이디어의 도입이 필요합니다.  
최소한의 텍스트 기반 RPG 게임을 구현하고 이 문제에 적합한 최상의 모범 사례를 적용해야 합니다.  
프로젝트가 끝나면 애플리케이션의 다른 부분으로부터 UI 또는 View를 추상화하는 방법에 대해서 이해하게 됩니다.

## 목표
한 힙스터 기업가 그룹이 새로운 텍스트 기반 RPG를 출시하려고 합니다.  
그들은 아름다운 그래픽이 중요하다고 생각하지 않고, 게임 플레이가 성공적인 게임을 만들기 위한 가장 중요한 부분이라고 생각하기 때문에,
다른 분야에 투자하고 텍스트 기반 게임을 만들기로 결정했습니다.  
심지어 2단계로 나누어 출시할 계획이라고 합니다:  
  - 첫 번째 단계는 하드코어한 힙스터를 위한 콘솔 기반 게임입니다.
  - 두 번째 단계는 사용자 입력을 받기 위해 간단한 GUI를 가지는 일반 힙스터를 위한 게임입니다.
  
그들은 당신과 함께 일하면 최고의 제품을 얻을 수 있다는 것을 알기 때문에 당신의 Java 상점을 찾아옵니다.  
이들은 주로 기능에 관심을 갖지만, 구현해야 할 프로그래밍 요구 사항도 있습니다:  
  - Model-View-Controller 디자인 패턴 존중
  - Maven을 통한 자동화된 빌드.
  - Annotation 기반 사용자 입력 유효성 검사.
  
훌륭하고 명확한 구현만 허용됩니다.  
이를 위해서는 다음과 같은 조건이 필요합니다.  
디자인이 깔끔하고, 동료들이 읽고 이해하기 쉬우며, 요구 사항이 수정될 경우
요구 사항이 수정될 경우 변경하기 쉬워야 합니다.

> Builder pattern

> Hibernate Validator

> 주요 IDE는 Maven에 대한 지원을 잘 지원합니다.  
> 사용자는 실행 가능한 jar 파일을 생성하려면 Maven 플러그인 시스템에 대해 배워야 합니다.

## 일반 지침들
- 최신 Java LTS 버전까지 언어 기능을 사용할 수 있습니다.
- 외부 라이브러리, 빌드 도구 또는 code generators를 사용할 수 있습니다.
- default package를 사용하지 마세요.
- Java 패키지 명명 규칙에 따라 관련 패키지를 직접 생성하세요.
- Java는 중간 언어로 컴파일됩니다. 그러면 일부 .class 파일이 생성됩니다. 리포지토리에 커밋하지 마세요!
- 터미널에서 javac 및 java를 명령으로 사용할 수 있는지 확인하세요.
- mvn 명령줄 도구를 사용할 수 있는지 확인하거나 IDE에 번들로 제공되는 것을 사용하세요.
- 프로젝트 폴더의 루트에서 아래 명령을 실행하는 프로젝트를 빌드합니다.  
이렇게 하면 게임을 실행할 수 있는 실행 가능한 .jar 파일이 생성되어야 합니다.
```
$mvn clean package
```

## 필수 부분
아래에 설명된 게임 플레이 및 조건을 기반으로 텍스트 기반 RPG를 구현해야 합니다.  
프로그램은 Model-View-Controller 아키텍처를 따라야 하며, 콘솔 뷰와 GUI 뷰 사이를 전환할 수 있어야 합니다.
### 게임 플레이
플레이어는 다양한 유형의 영웅을 여러 명 보유할 수 있습니다.  
영웅의 유형에 이름을 지정하고 시작 능력치를 미세 조정하는 것은 당신에게 맡기겠습니다.  
플레이어가 게임을 시작할 때, 두 가지 옵션이 있습니다:
- 영웅 생성
- 이전에 생성한 영웅을 선택

두 경우 모두 플레이어는 영웅 스탯을 볼 수 있습니다:
- 영웅 이름
- 영웅 클래스
- 레벨
- 경험치
- 공격력
- 방어력
- Hit Points

영웅 스탯은 영웅 레벨과 유물의 영향을 받습니다.  
유물은 세 가지 유형이 있습니다:
- 무기 - 공격력 증가
- 갑옷 - 방어력 증가
- 투구 - Hit points 증가

영웅을 선택하면 실제 게임이 시작됩니다.  
영웅은 (레벨 - 1) * 5 + 10 - (레벨 % 2) 공식으로 계산된 크기의 정사각형 맵을 탐색해야합니다. - (레벨 7의 영웅은 39X39 맵에 배치됩니다.)  
영웅의 초기 위치는 맵 중앙에 있습니다.  
영웅은 맵의 경계선에 도달하면 승리합니다.  
매 턴마다 다음 중 한 방향으로 한 위치를 이동할 수 있습니다.  
네 방향으로 이동할 수 있습니다:
- 북
- 동
- 남
- 서

지도가 생성되면, 다양한 힘을 가진 악당들이 지도에 무작위로 배치됩니다.  
영웅이 악당이 점령한 위치로 이동하면 영웅에게는 두 가지 옵션이 있습니다:
- 전투 - 영웅이 악당과 전투에 참여합니다.
- 도망 - 50%의 확률로 도망칠 수 있고, 실패 시 악당과 싸워야 합니다.

영웅과 몬스터의 전투를 시뮬레이션하고 사용자에게 전투 결과를 제시해야합니다.  
영웅과 몬스터의 능력치를 기반으로 누가 이길지 결정하는 멋진 시뮬레이션 알고리즘은 당신에게 맡기겠습니다.  
시뮬레이션 알고리즘에 작은 "운"을 추가하여 게임을 더욱 재미있게 만들 수 있습니다.  
  
영웅이 전투에서 패배하면 영웅은 죽고 임무도 잃게 됩니다.  
영웅이 전투에서 승리하면 이득을 얻습니다:
- 악당의 힘에 따라 경험치를 얻습니다. 물론 다음 레벨 경험치에 도달하면 레벨이 올라갑니다.
- 유물을 획득하여 보관하거나 버릴 수 있습니다. 물론 전투에서 승리한다고 해서 유물이 드랍되는 것은 아니며, 유물의 품질도 악당의 힘에 따라
악당의 힘에 따라 다릅니다.
  
레벨 업은 다음 공식에 따라 레벨 * 1000 + (레벨 - 1)ˆ2 * 450을 기준으로 합니다.  
따라서 레벨 업에 필요한 경험치는 이 패턴을 따릅니다:
- 레벨 1 - 1000 경험치
- 레벨 2 - 2450 경험치
- 레벨 3 - 4800 경험치
- 레벨 4 - 8050 경험치
- 레벨 5 - 12200 경험치
 
### 특징
게임은 아래와 같이 두 가지 모드로 실행할 수 있습니다.
```
$java -jar swingy.jar console
```
```
$java -jar swingy.jar gui
```
사용자가 게임을 종료할 때 사용자의 영웅과 그것들의 상태는 텍스트 파일에 저장됩니다.  
게임을 시작할 때, 프로그램은 이 파일에서 영웅을 로드합니다.

### 유효성
Annotation 기반 유효성 검사를 제공하려면, 프로젝트에 타사 라이브러리를 통합해야 합니다.  
javax.validation 사양을 구현하는 라이브러리를 사용하는 것을 추천합니다.  
비정상적인 사용자 입력으로 인해 게임 동작이 중단되지 않도록 해야 합니다.  
유효성 검사 실패는 사용자에게 강조 표시됩니다.

## 보너스 부분
다음과 같은 경우 보너스 포인트가 주어집니다:
- 사용자의 영웅을 텍스트 파일 대신 관계형 데이터베이스에 유지합니다.
- 게임을 종료하지 않고도 런타임에 콘솔 보기와 GUI 보기를 전환할 수 있습니다.
